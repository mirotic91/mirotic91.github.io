---
layout: post
title: "Ch12. 창발성"
subtitle: 단순한 설계 규칙을 지키자
date: 2019-04-17 22:06:00 +0900
categories: CleanCode
tags: CleanCode
---

# 창발성
---

#### 창발적 설계로 깔끔한 코드를 구현하자
착실하게 따르면 우수한 설계가 나오는 단순한 규칙 *(중요도 순)*
1. 모든 **테스트**를 실행한다.
2. **중복**을 없앤다.
3. 프로그래머 **의도**를 표현한다.
4. **클래스와 메서드 수**를 최소로 줄인다.

---

#### 단순한 설계 규칙 1: 모든 테스트를 실행하라

- 테스트가 가능한 시스템을 만들려고 하면 크기가 작고 목적 하나만 수행하는 클래스가 나온다.
- 테스트 케이스가 많을수록 개발자는 테스트가 더 쉽게 코드를 작성한다.
- 결합도가 높으면 테스트 케이스를 작성하기 어려우므로 개발자는 `DIP` 와 같은 원칙을 적용하는 등 결합도를 낮춘다. 따라서 설계 품질은 더욱 높아진다.

**즉, 테스트 케이스를 작성하면 설계 품질이 높아진다.**

---

#### 단순한 설계 규칙 2~4: 리팩터링
- 테스트 케이스를 모두 작성했다면 코드를 점진적으로 리팩터링 해나간다.
- 테스트 케이스가 있기에 코드를 정리하며 시스템이 깨질까 걱정할 필요가 없다.

> 리팩터링 단계에서는 소프트웨어 설계 품질을 높이는 기법이라면 무엇이든 적용해도 괜찮다.
응집도를 높이고, 결합도를 낮추고, 관심사를 분리하고, 시스템 관심사를 모듈로 나누고, 함수와 클래스 크기를 줄이고, 더 나은 이름을 선택하는 등 다양한 기법을 동원한다.
또한 나머지 단순한 설계 규칙인 중복을 제거하고, 프로그래머 의도를 표현하고, 클래스와 메서드 수를 최소로 줄이는 단계이기도 하다.

---

#### 중복을 없애라
* **중복**은 추가 작업, 추가 위험, 불필요한 복잡도를 뜻한다.
* 코드 중복을 제거하기 위해 좀 더 추상화시켜 새 메서드로 추출한다면 다른 맥락에서 **재사용**할 기회를 포착할지도 모른다. 
이런 소규모 재사용은 시스템 복잡도를 극적으로 줄여준다.

고차원 중복을 제거할 목적으로 자주 사용하는 `TEMPLATE METHOD 패턴` 의 예제이다.
```java
// before
public class VacationPolicy {
    
  public void accrueUSDDivisionVacation() {
    // 지금까지 근무한 시간을 바탕으로 휴가 일수를 계산하는 코드
    // ...
    // 휴가 일수가 [미국] 최소 법정 일수를 만족하는지 확인하는 코드
    // ...
    // 휴가 일수를 급여 대장에 적용하는 코드
    // ...
  }
  
  public void accrueEUDivisionVacation() {
    // 지금까지 근무한 시간을 바탕으로 휴가 일수를 계산하는 코드
    // ...
    // 휴가 일수가 [유럽연합] 최소 법정 일수를 만족하는지 확인하는 코드
    // ...
    // 휴가 일수를 급여 대장에 적용하는 코드
    // ...
  }
}
```
최소 법정 일수를 계산하는 알고리즘은 직원 유형에 따라 살짝 변한다. 나머지 두 메서드는 거의 동일하다.
여기에 *TEMPLATE METHOD 패턴*을 적용해 눈에 들어오는 **중복**을 제거한다.
```java
//after
abstract public class VacationPolicy {
    
  public void accrueVacation() {
    caculateBseVacationHours();
    alterForLegalMinimums();
    applyToPayroll();
  }
  
  private void calculateBaseVacationHours() { /* ... */ };
  abstract protected void alterForLegalMinimums();
  private void applyToPayroll() { /* ... */ };
}

public class USVacationPolicy extends VacationPolicy {
    
  @Override 
  protected void alterForLegalMinimums() {
    // [미국] 최소 법정 일수를 사용한다.
  }
}

public class EUVacationPolicy extends VacationPolicy {
    
  @Override 
  protected void alterForLegalMinimums() {
    // [유럽연합] 최소 법정 일수를 사용한다.
  }
}
```

---

#### 표현하라
* 자신이 이해하는 코드를 짜기는 쉽다. 하지만 나중에 코드를 유지보수할 사람이 코드를 짜는 사람만큼이나 문제를 깊이 이해할 가능성은 희박하다.
* 시스템이 점차 복잡해지면서 유지보수 개발자가 시스템을 이해하느라 보내는 시간은 점점 늘어나고 동시에 코드를 오해할 가능성도 점점 커진다. 
그러므로 **코드는 개발자의 의도를 분명히 표현해야 한다.** 
개발자가 의도를 명확히 한다면 다른 사람이 그 코드를 이해하기 쉬워진다. 그래야 결함이 줄어들고 유지보수 비용이 적게 든다.

##### 표현 방법
1. 좋은 **이름**을 선택하라.
2. 함수와 클래스 **크기**를 가능한 줄인다.
3. **표준 명칭**을 사용한다. ex) Design Pattern
4. **단위 테스트 케이스**를 꼼꼼히 작성한다.

---

#### 클래스와 메서드 수를 최소로 줄여라
* 클래스와 메서드 크기를 줄이고자 조그만 클래스와 메서드를 수없이 만드는 사례도 없지 않다. 그래서 이 규칙은 함수와 클래스 수를 가능한 줄이라고 제안한다.
* 목표는 함수와 클래스 크기를 작게 유지하면서 동시에 시스템 크기도 작게 유지하는 데 있다. 
그러나 클래스와 함수 수를 줄이는 작업도 중요하지만, **테스트 케이스를 만들고 중복을 제거하고 의도를 표현하는 작업**이 더 중요하다.

---

#### 결론
**경험**을 대신할 단순한 개발 기법이 있을까? 당연히 없다.    
단순한 설계 규칙을 따른다면 훗날 우수한 기법과 원칙을 단번에 활용할 수 있다.

<br>
##### Reference
- *CleanCode 애자일 소프트웨어 장인 정신*
